<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Risk</title>
    <!--
    LICENSE

    This web page is distributed under the GNU General Public License v3 
    (GPL v3).

    It is based on, and borrows code from, the Binary Risk Analysis App 
    (https://binary.protect.io) written by Ben Sapiro, which is also licensed
    under GPL v3, and its use here complies with the terms of that license.

    Binary Risk Analysis is a process for quickly assessing the risk
    of an event. The methodology and algorithms for Binary Risk Analysis
    are explained at https://binary.protect.io and licensed under  
    CC BY-SA 3.0.

    This updated version of the Binary Risk Analysis App can be found at
    https://github.com/SafetyLight/BinaryRisk.

    Copyright (C) 2024 by Brian Myers (brian @ safetylight dot dev)

    This program is free software. You can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    A copy of the license is in LICENSE which can be found at
    https://github.com/SafetyLight/BinaryRisk/blob/main/LICENSE.

    The complete GNU General Public License is available at
    http://www.gnu.org/licenses/.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.
-->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
        }

        h1 {
            background-color: #333;
            color: #fff;
            padding: 15px 0;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .button-container {
            position: absolute;
            right: 20px;
            display: flex;
            gap: 5px;
        }

        .header-button {
            padding: 4px 10px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .header-button:hover {
            background-color: #888;
        }

        .content-container {
            align-items: center;
            margin: 20px;
            display: flex;
            gap: 20px;
        }

        .content {
            max-width: 600px;
            flex-grow: 1;
        }

        .instructions {
            font-size: larger;
            margin-bottom: 2em;
        }

        .question {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }

        .question-text {
            flex: 1;
        }

        .question-options {
            min-width: 120px;
            text-align: right;
        }

        .question-options label {
            margin-left: 8px;
        }

        .result-container {
            display: flex;
            flex-direction: column;
            text-align: center;
            margin-left: 5em;
        }

        #result {
            font-family: Arial, Helvetica, sans-serif;
            font-weight: bold;
            font-size: 1.2em;
            border: 1px solid #ddd;
            padding: 20px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .result-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 10px;
        }

        .result-item .label {
            margin-right: 20px;
        }

        .value-box {
            width: 100px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .low {
            background-color: limegreen;
            color: white;
        }

        .medium {
            background-color: orange;
            color: white;
        }

        .high {
            background-color: red;
            color: white;
        }
    </style>
</head>

<body>
    <h1>
        Binary Risk Analysis
        <div class="button-container">
            <button class="header-button reset-button" onclick="resetState()">Reset</button>
            <button class="header-button clipboard-button" onclick="copyUrlToClipboard()">Clipboard</button>
        </div>
    </h1>

    <div class="content-container">
        <div class="content">
            <p class="instructions">Answer these ten questions to assess a risk:</p>
            <div id="questions">
                <!-- Render questions dynamically with JavaScript -->
            </div>
        </div>

        <div class="result-container">
            <div id="result">
                <div class="result-item">
                    <span class="label">Risk Level</span>
                    <span class="value-box" id="risk-value">TBD</span>
                </div>
                <div class="result-item">
                    <span class="label">Likelihood</span>
                    <span class="value-box" id="likelihood-value">TBD</span>
                </div>
                <div class="result-item">
                    <span class="label">Impact</span>
                    <span class="value-box" id="impact-value">TBD</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const questions = [
            "Can the attack be completed with common skills?",
            "Can the attack be completed without significant resources?",
            "Is the asset undefended?",
            "Are there known weaknesses in the current defenses?",
            "Is the vulnerability in the asset always present?",
            "Can the attack be performed without meeting preconditions?",
            "Will there be consequences from internal sources?",
            "Will there be consequences from external sources?",
            "Does the asset have or create significant business value?",
            "Will the repair or replacement costs be significant?"
        ];

        const questionsContainer = document.getElementById('questions');

        const updateVisuals = {
            "Low": "low",
            "Medium": "medium",
            "High": "high"
        };

        // Safer URL handling. Avoids a security exception from FireFox.
        function getInitialState() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const state = urlParams.get('state');
                if (state && /^[01]{10}$/.test(state)) {
                    return state;
                }
            } catch (e) {
                console.warn('Error parsing URL parameters:', e);
            }
            return '0000000000';
        }

        let initialState = getInitialState();

        function initializeQuestions() {
            questionsContainer.innerHTML = '';
            questions.forEach((question, index) => {
                const isCheckedYes = initialState[index] === '1';
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question';
                questionDiv.innerHTML = `
                    <span class="question-text">${question}</span>
                    <div class="question-options">
                        <input type="radio" name="question${index}" id="yes${index}" value="1" ${isCheckedYes ? 'checked' : ''} onchange="updateState()">
                        <label for="yes${index}">Yes</label>
                        <input type="radio" name="question${index}" id="no${index}" value="0" ${!isCheckedYes ? 'checked' : ''} onchange="updateState()">
                        <label for="no${index}">No</label>
                    </div>
                `;
                questionsContainer.appendChild(questionDiv);
            });
        }

        function calculateRisk(binaryString, likelihoodScore, impactScore) {
            let calculatedScore;

            const riskSum = likelihoodScore + impactScore;
            switch (riskSum) {
                case 2:
                case 3:
                    calculatedScore = Math.pow(2, 0);
                    break;
                case 4:
                case 5:
                    calculatedScore = Math.pow(2, 1);
                    break;
                case 6:
                case 8:
                    calculatedScore = Math.pow(2, 2);
                    break;
                default:
                    calculatedScore = 0;
            }
            return calculatedScore;
        }

        function calculateLikelihood(binaryString) {
            const CALCSTART = 0;
            const CALCSTOP = 5;
            const CALCBLOCKSIZE = 2;
            return chunkScore(binaryString, CALCSTART, CALCSTOP, CALCBLOCKSIZE);
        }

        function calculateImpact(binaryString) {
            const CALCSTART = 6;
            const CALCSTOP = 9;
            const CALCBLOCKSIZE = 2;
            return chunkScore(binaryString, CALCSTART, CALCSTOP, CALCBLOCKSIZE);
        }

        function chunkScore(binaryString, startIndex, stopIndex, blockSize) {
            const BINARYMASK = '0000000011';
            const BINARYMASK_BLOCK = '0000000001';
            const INTMASK = parseInt(BINARYMASK, 2);
            const INTMASK_BLOCK = parseInt(BINARYMASK_BLOCK, 2);
            let scoreAccumulator = 0;

            for (let shifter = startIndex; shifter <= stopIndex; shifter += blockSize) {
                let blockScore = (binaryString >>> shifter) & INTMASK;
                let blockScorePartA = blockScore & INTMASK_BLOCK;
                let blockScorePartB = (blockScore >>> 1) & INTMASK_BLOCK;
                let calculatedScore = Math.pow(2, blockScorePartA + blockScorePartB);

                switch (scoreAccumulator) {
                    case 0:
                    case 2:
                        scoreAccumulator = calculatedScore;
                        break;
                    case 1:
                        scoreAccumulator = (calculatedScore === 4 ? 2 : 1);
                        break;
                    case 4:
                        scoreAccumulator = (calculatedScore === 1 ? 2 : 4);
                        break;
                }
            }

            return scoreAccumulator;
        }

        function updateState() {
            let state = '';

            for (let index = 0; index < questions.length; index++) {
                const answer = document.querySelector(`input[name="question${index}"]:checked`);
                state += answer && answer.value === '1' ? '1' : '0';
            }

            try {
                updateUrl(state);
            } catch (e) {
                console.warn('Error updating URL:', e);
            }

            updateResults(state);
        }

        function updateResults(state) {
            let reversedState = state.split("").reverse().join("");
            const stateInt = parseInt(reversedState, 2);     // The calculations expect the state to be reversed
            const likelihoodScore = calculateLikelihood(stateInt);
            const impactScore = calculateImpact(stateInt);
            const riskScore = calculateRisk(stateInt, likelihoodScore, impactScore);

            updateResult("risk-value", getCategory(riskScore));
            updateResult("likelihood-value", getCategory(likelihoodScore));
            updateResult("impact-value", getCategory(impactScore));
        }

        function getCategory(score) {
            const WORDS = ['Low', 'Medium', 'High'];
            const index = (Math.log(score)) / (Math.log(2));
            return WORDS[index] || WORDS[0];
        }

        function updateResult(elementId, level) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = level;
                element.className = `value-box ${updateVisuals[level]}`;
            }
        }

        function updateUrl(state) {
            try {
                const newUrl = new URL(window.location.href);
                newUrl.searchParams.set('state', state);
                window.history.replaceState({}, '', newUrl);
                let newState = new URL(location.href).searchParams.get('state')
            } catch (e) {
                console.warn('Error updating URL:', e);
            }
        }

        function resetState() {
            const defaultState = '0000000000';
            initialState = defaultState;
            updateUrl(initialState);
            initializeQuestions();
            updateResults(initialState);
        }

        function copyUrlToClipboard() {
            try {
                const url = window.location.href;
                navigator.clipboard.writeText(url).then(() => {
                    console.log("URL copied to clipboard.");
                }).catch((error) => {
                    console.error("Failed to copy URL:", error);
                });
            } catch (e) {
                console.warn("Clipboard API not supported:", e);
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            initializeQuestions();
            updateState();
        });
    </script>
</body>

</html>